# 아이템 11 잉여 속성 체크의 한계 인지하기

- 타입이 명시된 변수에 객체 리터럴을 할당할 때 TS는 해당 타입의 속성이 있는지, 그리고 ‘그 외의 속성은 없는지’ 확인한다.

### Room의 구조적 타이핑

```tsx
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}

const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: "present", //오류메세지 : 개체리터럴은 알려진 속성만 지정할 수 있으며 'Room' 형식에 elephant 가 없습니다.
}
```

- 구조적 타이핑관점으로 생각해보면 오류가 발생하지 않아야 한다.
- 구조적 타입 시스템에서 발생할 수 있는 오류를 잡을 수 있도록 ‘잉여속성 체크’ 라는 과정이 수행되었다.
  - 변수에 타입을 명시적으로 선언했을 때 우리가 기대하는 `할당 가능 검사`와는 별도의 과정이라는 것을 알아야 한다.

```tsx
const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: "present",
};
const r: Room = obj; // 정상
```

- 임시변수 obj 객체는 Room 타입 할당이 가능하다.
- obj 타입은 Room 타입의 부분집합 (numbDoors, ceilingHeightFt) 을 포함하므로, Room 에 할당 가능하며 타입체커를 통과할 수 있다.

## 잉여 속성 체크

- 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여속성체크가 수행된다.
- 객체 리터럴에 포함되지 않은 속성이 객체에 할당되려고 할때, 타입스크립트는 이를 ‘잉여속성’ 이라고 판단하고 컴파일 오류를 발생시킨다.

### 의도와 다른 코드 체크

- 타입스크립트는 단순히 런타임에 예외를 던지는 코드에 오류를 표시할 뿐만 아니라, **의도와 다르게 작성된 코드**도 찾는다.
  - darkmode → 오류로 체크해 darkMode로 바꿀 것을 제안한다.
- 아래의 예시에서 Options는 타입의 범위가 매우 넓다.
  - document / HTMLAnchorElement의 인스턴스 모두 string 타입이다.
  - 그러나, title / darkMode 객체는 체크가 된다.
    - 따라, darkMode로 바꿀 것을 제안하게 되는 것

```tsx
interface Options {
  title: string;
  darkMode?:boolean
}
const o1: Options = document; //객체 리터럴이 아니기 때문에 잉여속성체크 하지 않음
const o2: Options = new HTMlAnchorElement; // 객체 리터럴이 아니기 때문에 잉여속성체크 하지 않음
```

- 잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름의 오타 같은 실수를 잡는데 효과적인 방법이다.
- 선택적 필드를 포함하는 Options 같은 타입에 특히 유용하지만, 적용 범위가 제한적이고 오직 객체 리터럴에만 적용된다.
  - 잉여속성체크와 일반타입체크를 구분해서 적절하게 도움을 받자 (아이템 18, 26에서 다룸)

### **요약**

- 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다.
- 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만 타입스크립트 타입 체커가 수행하는 구조적 할당 가능성 체크와 역할이 다르다.
- 잉여 속성 체크에는 임시변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다는 한계가 있다.



---

# 아이템 12 함수 표현식에 타입 적용하기

- 자바스크립트에서는 함수 ‘문장’과 함수 ‘표현식’을 다르게 인식한다.

```tsx
function rollDice1(sides: number) : number {/* ... */} //문장
const rollDice2 = function(sides: number) : number {/* ... */} //표현식
const rollDice3 = (sides: number) : number => {/* ... */} //표현식
```

- 타입스크립트에서는 함수 표현식을 사용하는 것이 좋다.
  - 함수의 매개변수부터 반환값까지 전체를 함수 타입으로 선언해 함수 표현식에 재사용할 수 있다는 장점이 있기 때문이다.

### 장점1 : 함수 타입의 선언은 불필요한 코드의 반복을 줄인다.

```tsx
function add (a : number, b: number) {return a + b; }
function sub (a : number, b: number) {return a - b; }
function mul (a : number, b: number) {return a * b; }
function div (a : number, b: number) {return a / b; }

type BinaryFn = (a : number, b:number) => number;
const add : BinaryFn = (a,b) => a+b;
const sub : BinaryFn = (a,b) => a-b;
const mul : BinaryFn = (a,b) => a*b;
const div : BinaryFn = (a,b) => a/b;
```

- 사칙 연산을 하는 함수 네개에서 반복되는 함수 시그니처를 하나의 함수 타입으로 선언해 사용했다.
- 타입구문이 적고, 함수 구현부도 분리되어있어 로직이 보다 분명해진다.

### 장점2 : 안전하게 오류를 체크한다.

### 시그니처가 일치하는 다른 함수

- `quote` 가 존재하지 않을 때 404 응답을 보낸다.
- 응답은 JSON 형식이 아닐 수 있다. → 새로운 오류 등장
- 원래 오류인 404가 감춰진다. (새로운 오류메시지가 전달되었기 때문)

```tsx
const responseP = fetch('/quote?by=Mark+Twain') // Type is Promise<Response>
async function getQuote() {
  const response = await fetch('/quote?by=Mark+Twain')
  const quote = await response.json()
  return quote
}
```

- 함수 문장을 함수 표현식으로 바꾸고, 함주 전체에 타입 

  ```
  typeof fetch
  ```

  를 적용한다.

  - 타입스크립트가 `input`과 `init`의 타입을 추론할 수 있게 되었다.

```tsx
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init)
  if (!response.ok) {
    throw new Error('Request failed: ' + response.status)
  }
  return response
}

declare function fetch(
	input : RequuestInfo, init?: RequestInit
): Promise<Response>;
```

- 함수의 매개변수에 타입을 선언하는 것보다 함수 표현식 전체 타입을 정의하는 것이 코드도 간결하고 안전하다.
- 다른 함수의 시그니처와 동일한 타입을 가지는 새 함수를 작성하거나, 동일한 타입 시그니처를 가지는 여러 개의 함수를 작성할 때는 매개변수의 타입과 반환 타입을 반복해서 작성하지 말고 함수 전체의 타입 선언을 적용해야 한다.

### 요약

- 반환값이나 매개변수에 타입을 명시하는 것 보다 함수 표현식 전체에 타입 구문을 적용하는 것이 좋다.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해내거나 이미 존재하는 타입을 찾아보도록 한다.
  - 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야 한다.
- 다른 함수의 시그니처를 참조하려면 `typeof fn` 을 사용하면 된다.





----

# 아이템 13 타입과 인터페이스의 차이점 알기

- 타입스크립트에서 명명된 타입을 정의하는 방법은 두 가지가 있다.
  - 클래스를 사용할 수도 있지만, 클래스는 값으로도 쓰일 수 있는 자바스크립트 런타임 개념이다. (아이템 8에서 설명했음)
- 대부분의 경우 타입을 사용해도 되고, 인터페이스를 사용해도 된다.
- 타입과 인터페이스 사이에 존재하는 차이를 명확히 알고 같은 상황에서 동일한 방법으로 명명된 타입을 정의해 일관성을 유지해야 한다.

### 1. type 키워드 사용

```tsx
type TState = {
	name : string;
	capital : string;
}
```

### 2. 인터페이스 사용

```tsx
interface IState {
    name: string;
    capital: string;
}
```

### 3. 비슷한 점

- 명명된 타입은 인터페이스로 정의하든 타입으로 정의하는 상태에는 차이가 없다.

### 1) 추가속성과 함께 할당한다면 동일한 오류가 발생한다.

```tsx
const wyoming: TState = {
    name: 'wyoming',
    capital: 'Cheyenne',
    population: 500_000
};
//오류메세지 :  개체리터럴은 알려진 속성만 지정할 수 있으며 TState (또는 IState) 형식에 population이 없다.
```

### 2) 인덱스 시그니처를 사용할 수 있다.

```tsx
//타입
type TDict = {[key: string]: string};

//인터페이스
interface IDict {
    [key: string]: string;
}
```

### 3) 함수타입의 정의가 가능하다.

```tsx
//타입
type TFn = (x: number) => string;
const toStrT: TFn = x => '' + x;

//인터페이스
interface IFn{
    (x: number): string;
}
const toStrI: IFn = x => '' + x;
```

### 4) 제너릭이 가능하다

- **제네릭이란 타입을 마치 함수의 파라미터처럼 사용하는 것**을 의미함

```tsx
type TPair<T> = {
    first: T;
    second: T;
}

interface IPair<T>{
    first: T;
    second: T;
}
```

### 5) 서로 확장이 가능하다.

- type 을 extends 한 interface
- interface 를 extends 한 type

```tsx
interface IStateWithPop extends TState{
    population: number;
}

type TStateWithPop = IState & {population: number;};
```

### 4. 차이점

### 1) 유니온 인터페이스는 존재하지 않음 (유니온 타입은 있음)

```tsx
type AorB = 'a' | 'b';
```

- 인터페이스는 타입을 확장할 수 있지만, 유니온은 할 수 없다.
  - 그렇지만 유니온 타입을 확장하는 것이 필요할 때가 있다.

확장방법 1) Input | Output 타입을 갖는 객체를 표현하는 VariableMap 인터페이스

```tsx
type Input = {};
type Output = {};
interface VariableMap {
    [name: string]: Input | Output;
}
```

확장방법 2) 유니온타입에 name 속성을 붙인 타입 NamedVariable 타입

```tsx
type NamedVariable = (Input | Output) & {name: string};
```

### 2) 인터페이스는 보강이 가능하다

- 타입선언에는 사용자가 채워야하는 빈틈이 있을 수 있다. (선언병합 필요 - 6장)
- 선언병합을 지원하기 위해 반드시 인터페이스를 사용해야 한다. (보강)
- 병합은 선언처럼 일반적인 코드라서 언제든지 가능하다.
  - 프로퍼티가 추가되는 것을 원하지 않는다면 인터페이스 대신 타입을 사용할 수 있다.

```tsx
//선언병합 예제
interface IState {
    name: string;
    capital: string;
}

interface IState {
    population: number;
}

const wyoming:IState = {
    name: 'Wyoming',
    capital: 'Cheyenne',
    population: 500_000 // 정상
};
```

### 5. 무엇을 사용해야 할까?

- 타입과 인터페이스 중 어느 것을 사용해야 할까?
- 복잡한 타입이라면 타입별칭을 사용하면 된다.
- 타입과 인터페이스. 두 가지 방법으로 모두 표현할 수 있는 간단한 객체 타입이라면 일관성과 보강의 관점에서 고려해야 한다.
- 이미 프로젝트가 진행중일 때 :
  - 일관되게 인터페이스를 사용하는 코드베이스라면, 인터페이스를 사용한다.
  - 반대의 경우에는 타입을 사용한다.
- 아직 스타일이 확립되지 않은 프로젝트 일 때 :
  - 향후에 보강의 가능성이 있을지 생각해야 한다.
  - API에 타입 선언을 작성한다면 인터페이스를 사용해라
    - API가 변경될 때 사용자가 인터페이스를 통해 새로운 필드를 병할 할 수 있기 때문이다.
  - 프로젝트 내부적으로 사용되는 타입에 선언 병합이 발생하는 것은 잘못된 설계다.
    - 타입을 사용해라

### 요약

- 타입과 인터페이스의 차이점과 비슷한 점을 이해해야 한다.
- 한 타입을 type 과 interface 두 가지 문법을 사용해서 작성하는 방법을 터득해야 한다.
- 프로젝트에서 어떤 문법을 사용할지 결정할 때 한 가지 일관된 스타일을 확립하고, 보강 기법이 필요한지 고려해야 한다.



---

# 아이템 14 타입 연산과 제너릭 사용으로 반복줄이기

- 코드를 짤 때는 같은 코드를 반복하지 말라는 DRY (don’t repeat yourself) 원칙이 있다.
- 타입에서도 같은 원칙을 적용해야 한다.
  - 타입 중복은 많은 문제를 발생시킨다.

### 방법 1 : 타입에 이름 붙이기

```tsx
function distance(a: { x: number; y: number }, b: { x: number; y: number }) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))
}

//상수를 사용해서 반복을 줄이는 기법 적용
interface Point2D {
  x: number
  y: number
}
function distance(a: Point2D, b: Point2D) {
  /* ... */
}
```

### 방법 2 : 같은 시그니처를 공유하고 있는 함수는 명명된 타입으로 분리해 반복 줄이기

```tsx
//같은 시그니처 공유
function get(url: string, opts: Options): Promise<Response> {
  /* COMPRESS */ return Promise.resolve(new Response()) /* END */
}
function post(url: string, opts: Options): Promise<Response> {
  /* COMPRESS */ return Promise.resolve(new Response()) /* END */
}

//명명 타입으로 분리
type HTTPFunction = (url: string, options: Options) => Promise<Response>
const get: HTTPFunction = (url, options) => {
  /* COMPRESS */ return Promise.resolve(new Response()) /* END */
}
const post: HTTPFunction = (url, options) => {
  /* COMPRESS */ return Promise.resolve(new Response()) /* END */
}
```

### 방법3 : 한 인터페이스가 다른 인테페이스를 확장

```tsx
interface Person {
  firstName: string
  lastName: string
}

interface PersonWithBirthDate extends Person {
  birth: Date
}
```

### 방법 4 : 이미 존재하는 타입을 확장하는 경우에는 인터섹션 연산자(&) 사용

```tsx
interface Person {
  firstName: string
  lastName: string
}

type PersonWithBirthDate = Person & { birth: Date }
```

### 방법 5 : State 인덱싱 → 중복 제거

```tsx
//방법 5, 6, 공통 예제
//전체 상태를 표현하는 State 타입과 부분만 표현하는 TopNavState가 있는 경우

interface State {
  userId: string
  pageTitle: string
  recentFiles: string[]
  pageContents: string
}
interface TopNavState {
  userId: string
  pageTitle: string
  recentFiles: string[]
}
type TopNavState = {
  userId: State['userId']
  pageTitle: State['pageTitle']
  recentFiles: State['recentFiles']
}
```

### 방법 6 : 매핑된 타입을 사용

```tsx
type TopNavState = {
  [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k]
}
```

- 매핑된 타입
  - 매핑된 타입은 `in` 키워드를 사용해 배열이나 튜플 등의 타입에 대해 루프를 도는 것과 같은 방식으로 새로운 타입을 만들어내는 기능이고, 주로 객체나 배열의 타입변환에 사용된다.
  - 이 패턴은 표준 라이브러리에서도 일반적으로 찾을 수 있으며, Pick 이라고 한다.
- Pick
  - Pick 은 제네릭 타입으로 첫번째 인자로 객체타입을, 두번째 인자로 해당 객체 타입에서 추출하고자 하는 필드의 이름들을 문자열 리터럴 타입 배열로 받는다.
  - Pick 을 사용해서 State 에서 userId, pageTtiel, recentFiles 필드만 추출해서 간단하게 새로운 타입을 만들 수 있다.

```tsx
type Pick<T, K> = { [k in K]: T[k] };
```

### 방법 7 : 유니온 인덱싱

- 중복 발생 : 태그된 유니온에서도 다른 형태의 중복이 발생할 수 있다.
- 태그된 유니온 : 유니온 타입에 문자열 리터럴 타입을 추가해서 타입 안전성을 높인 방법

```tsx
interface SaveAction {
  type: 'save'
  // ...
}
interface LoadAction {
  type: 'load'
  // ...
}
type Action = SaveAction | LoadAction
type ActionType = 'save' | 'load' // Repeated types!
//Action 유니온 인덱싱을 하면 타입 반복없이 ActionType 을 정의할 수 있다
type ActionType = Action['type'] // Type is "save" | "load"
type ActionRec = Pick<Action, 'type'>; //{type: "save" | "load"}
```

### 방법 8 :  **keyof**

- keyof 는 타입을 받아서 속성 타입의 유니온을 반환한다

```tsx
interface Options{
    width: number;
    height: number;
    ocolor: string;
    label: string;
}

interface OptionsUpdate{
    width?: number;
    height?: number;
    color?: string;
    label?: string;
}

type OptionsUpdate = {[k in keyof Options]?: Options[k]};
```

### 방법 9 : **typeof**

- 값의 형태에 해당하는 타입을 정의하고 싶을 때 사용

```tsx
//사용 전
const INIT_OPTIONS = {
    width: 640,
    height: 480,
    color: '#00FF00',
    label: 'VGA',
};

interface Options{
    width: number,
    height: number,
    color: string,
    label: string,   
}

//사용 후
type Options = typeof INIT_OPTIONS
```

### 방법 10 : **ReturnType**

- 함수나 메서드의 반환값에 명명된 타입을 만들고 싶을 수 있다.
- ReturnType 을 사용해 함수의 반환 타입을 변수로 선언하거나 다른 타입의 매개변수로 전달할 수 있다.

```tsx
function getUserInfo(userId: string){
    //...
    return {
        userId,
        name,
        age,
        height,
        weight,
        favoriteColor
    };
}

type UserInfo = ReturnType<typeof getUserInfo>;
```

- 위 코드에서 ReturnType 은 함수의 타입인 typeof getUserInfo 에 적용되었다.
- 적용대상이 값인지 타입인지 정확하게 알고 구분해서 처리해야 한다.

### 방법 11 : **제너릭타입**

- 제너릭 타입은 타입을 위한 함수와 같습니다.
- 제네릭 타입은 타입스크립트에서 DRY 원칙을 적용하는 핵심 방법 중 하나다.
- 제너릭을 사용하면 타입의 중복을 최소화하고 재사용성을 높일 수 있다.

```tsx
function addNumbers(a: number, b: number): number {
  return a + b;
}

function concatenateStrings(a: string, b: string): string {
  return a + b;
}

//제너릭으로 변경
function combine<T>(a: T, b: T): T {
  return a + b;
}
```

- combine 함수는 `T` 라는 타입의 매개변수를 사용한다.
- `T` 는 함수를 호출할 때 전달된 값의 타입으로 결정됩니다. 따라서 이 함수는 어떤 타입의 값을 합쳐서 반환할 수 있다.
- 제너릭 타입에서는 매개변수를 제한할 수 있는 방법이 필요다. (타입안전성을 보장하기 위해서)
- 제너릭 타입을 사용하면 여러 종류의 값들을 다룰 수 있는데, 제너릭 타입이 특정한 종류의 값만 다루도록 제한해야 하는 경우가 있다.
- **extends** 를 이용하면 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있고 이를 통해 매개변수를 제한할 수 있다.

```tsx
//제네릭 타입 매개변수 T 는 Name을 확장한다. 
//DancingDuo 타입은 T 타입의 배열이고, 요소는 Name 타입 객체로 이뤄져있다.
interface Name{
    first: string;
    last: string;
}

type DancingDuo<T extends Name> = [T,T];
```

### 방법 12 : **Pick**

```tsx
type Pick<T, K extends keyof T> = {
    [k in K]: T[k];
};
```

- Pick 타입은 T 타입에서 K 타입에 포함된 속성만 선택해 새로운 타입을 정의한다.
- 이 때 in 키워드를 사용한 매핑타입을 이용해서 새로운 객체 타입을 생성한다.

### 요약

- DRY 원칙을 타입에도 최대한 적용해야 한다.
- 타입에 이름을 붙여서 반복을 피하고, extends 를 사용해서 인터페이스 필드의 반복을 피해야한다.
- 타입들간의 매핑을 위해 매핑된 타입 keyof,typeof,인덱싱,매핑된 타입들을 공부해야한다.
- 제너릭 타입은 타입을 위한 함수와 같다. 타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는 것이 좋다.