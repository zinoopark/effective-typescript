# 아이템 56 정보를 감추는 목적으로 private 사용하지 않기

- 자바스크립트는 클래스에 비공개 속성을 만들 수 없음
  - _를 접두사로 붙이는 것이 관례
    - 언더 스코어를 붙임 = 단순히 비공개로 표시한 것
    - 따라서, 일반적인 속성과 동일하게 클래스 외부로 공개되어 있음
- 타입스크립트에는 public, protected, private 접근 제어자를 사용해서 공개 규칙을 강제할 수 있는 것으로 오해하곤 함
  - 그러나, 접근제어자는 타입스크립트 키워드이기 때문에 컴파일 후에는 제거됨

```tsx
//컴파일 이전
class Diary {
	constructor() {
		this.secret = 'cheated on my English test';
	}
}
const diary = new Diary();
diary.secret //'secret' 속성은 private이며, 클래스 내에서만 접근 가능~~

//컴파일 이후
class Diary {
	constructor() {
		this.secret = 'cheated on my English test';
	}
}
const diary = new Diary();
diary.secret
```

- private 키워드 사라짐, secret 일반적인 속성으로 접근 가능
- 결국, 접근 제어자들은 단지 컴파일 시점에만 오류를 표시해 줄 뿐, 언더스코어 관례와 마찬가지로 런타임에는 효력이 없음
- 정보를 숨기는 방법
  - 1번째 방법 : 클로저 사용
  - 2번째 방법 : 표준화가 진행 중인 비공개 필드 기능을 사용

### 요약

- public, protected, private 접근 제어자는 타입 시스템에서만 강제될 뿐 런타임에는 소용이 없으며 단언문을 통해 우회할 수 있음
- 접근 제어자로 데이터를 감추려고 하면 안됨
- 확실히 데이터를 감추고 싶다면 클로저를 사용해야 함



---

# 아이템 57 소스맵을 사용하여 타입스크립트 디버깅하기

- 타입스크립트 코드를 실행하는 것은 결국 타입스크립트 컴파일러가 생성한 자바스크립트 코드를 실행하는 것
- 디버깅 시에 더욱 타입스크립트가 직접 실행되는 것이 아니라는 것을 느낄 수 있다.
- 디버거는 런타임에 동작하며, 현재 동작하는 코드가 어떤 과정을 거쳐서 만들어진 것인지 알지 못하기 때문
- 변환된 자바스크립트 코드는 복잡해서 디버깅하기 매우 어렵다.
- 디버깅 문제를 해결하기 위한 해결책 : 소스맵
  - 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑한다.

### 소스맵에 대해 알아야 할 사항

- 타입스크립트와 함께 번들러, 압축기를 사용하고 있다면 각자의 소스맵을 생성하게 됨
  - 타입스크립트 원본 코드로 매핑되도록 해야 이상적인 디버깅 환경이 되는 것
- 상용 환경에 소스맵이 유출되고 있는지 확인해야 함
- NodeJS 프로그램의 디버깅에도 소스맵을 사용할 수 있음
- 타입  체커가 코드를 실행하기 전에 많은 오류를 잡을 수 있지만, 디버거를 대체할 순 없음
- 소스맵을 통해 제대로 된 타입스크립트 디버깅 환경을 구축하자

### 요약

- 원본 코드가 아닌 변환된 자바스크립트 코드를 디버깅하지 말자
- 소스맵을 사용해서 런타임에 타입스크립트 코드를 디버깅하자
- 소스맵이 최종적으로 변환된 코드에 완전히 매핑되었는지 확인하자
- 소스맵에 원본 코드가 그대로 포함되도록 설정되어 있을 수 있으니 공개되지 않도록 설정을 확인하자.



---

# 아이템 58 모던 자바스크립트로 작성하기

- 타입스크립트는 타입 체크 기능 외에, 타입스크립트 코드를 특정 버전의 자바스크립트로 컴파일 하는 기능을 가지고 있음
- 옛날 버전의 자바스크립트 코드를 타입스크립트 컴파일러에서 동작하게 만들면 이후로는 최신 버전의 자바스크립트 기느응ㄹ 추가해도 문제가 없음
- 마이그레이션을 어디서부터 시작해야 할 지 몰라 막막하다면 옛날 버전의 자바스크립트 코드를 최신 버전의 자바스크립트로 바꾸는 작업부터 시작하면 됨

결론 : 아이템 58은 모던 자바스크립트의 주요 기능을 다룸

### ECMAScript 모듈 사용하기

- ES2015부터는 임포트나 익스포트 대신 ECMAScript 모듈이 표준이 되었음
  - 타입스크립트에서 잘 동작하고 모듈 단위로 전환할 수 있게 해주므로 점진적 마이그레이션이 원활해짐

### 프로토타입 대신 클래스 사용하기

- 클래스 기반 모델은 프로토타입 모델보다 견고하게 설계되었음
- 마이그레이션 과정 이라면 클래스로 바꿀 것을 권장함
  - 문법이 훨씬 직관적이고 간결함
  - 또 타입스크립트 언어 서비스로 간단히 변환이 가능함

### var 대신 let/const 사용하기

- var 키워드의 스포크 규칙에 문제가 있다는 것은 모두가 알고 있는 사실
  - let과 const는 이 문제를 피할 수 있는 가장 빠른 방법이므로 var 사용을 지양해라

### for (;;) 대신 for-of 또는 배열 메서드 사용하기

- for-of 루프는 코드가 짧고 인덱스 변수를 사용하지 않기 때문에 실수를 줄일 수 있다.
  - 인덱스 변수가 필요하면 forEach를 사용해라

### 함수 표현식보다 화살표 함수 사용하기

- This는 특별한 스코프를 가지고 있다.
  - 화살표함수를 사용하면 상위 스코프의 this를 유지할 수 ㅣㅇㅆ다.
- 일반함수보다 화살표 함수가 훨씬 직관적이고 코드도 간결해진다.
- 컴파일 옵션에 noImplictThis를 설정하면, this 바인딩 관련 오류를 표시해주므로 함께 설정하는 것을 권장한다.

### 단축 객체 표현과 구조 분해 할당 사용하기

- 단축 객체 표현과 구조분해 할당을 사용하면 문법이 간결해진다.
- 변수를 사용할 때 실수도 줄일 수 있기 때문에 적극적으로 사용할 것을 권장한다.

### 함수 매개변수 기본값 사용하기

- 매개변수는 선택적이다.
- 매개변수의 기본값을 지정하면 코드가 간결해지고, 선택적 매개변수가 직관적으로 나타난다.
- 또, 기본값을 기반으로 타입 추론도 가능하기 때문에 마이그레이션 과정에서 타입 구문을 쓰지 않아도 된다.

### 저수준 프로미스나 콜백 대신 async/await 사용하기

- 아이템 25의 내용처럼 async와 await의 사용을 권장한다.
- 요점은 코드가 간결해져 버그나 실수를 방지할 수 있고, 비동기코드에 타입 정보가 전달되어 타입 추론을 가능하게 하기 때문이다.

### 연관 배열에 객체 대신 Map과 Set 사용하기

- 아이템 15에서 언급한 문제처럼 눈에 보이는 것에는 문제가 없어 보이지만 타입 추론에서의 문제점, 생성자 함수의 내정 등의 문제가 있을 수 있다.
- 객체 대신에 Map을 사용하면 좋다.

### 타입스크립트에 use strict 넣지 않기

- 타입스크립트에서 수행되는 안전성 검사가 엄격 모드보다 훨씬 더 엄격한 체크를 하기 때문에, 타입스크립트 코드에서 use strict는 무의미
- always strict 설정을 사용할 것

### 요약

- 타입스크립트 개발 환경은 모던 자바스크립트도 실행할 수 있으므로 모던 자바스크립트의 최신 기능들을 적극적으로 사용하된 된다.
  - 코드 품질과 타입 추론 모두 향상될 것
- 타입스크립트 개발 환경에서는 컴파일러와 언어 서비스를 통해 클래스, 구조분해, async / await 같은 기능을 쉽게 배울 수 있음
- use strict는 타입스크립트의 컴파일러 수준에서 사용되므로 코드에서 제거해야함