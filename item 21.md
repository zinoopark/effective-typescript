# Item 21 타입넓히기



### '넓히기'란

런타임에 모든 변수는 유일한 값을 가진다. 
그러나 정적 분석 시점에 변수는 '가능한' 값들의 집합인 타입을 가진다.

다시말하면 타입 체커는 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추하게 된다는 것이다.(값->값들의 집합)

말그대로 범위가 넓어졌으니, 이를 '넓히기(widening)'라고 부른다.

넓히기를 이해하면 오류 원인 파악이 쉬워지고 타입 구문을 더 효과적으로 사용할 수 있을 것이다. 이번 시간에는 넓히기에 대해서 알아보겠다.



### 타입 넓히기의 예


다음과 같은 함수가 있다고 가정하자.
```typescript
interface Vector3 {x: number; y: number; z: number;}
function getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {
	return vector[axis];
}
```

Vector3함수를 사용한 다음 코드는 ide에서 오류를 뿜는다(실행은 됨)
```typescript
let x = 'x';
let vec = {x: 10, y: 10, z:30}
getComponent(vec, x);
	            //~ 'string' 형식의 인수는 '"x" | " y " | "z"' 형식의 매개변수에 할당될 수 없습니다.
```

이유: 
getComponent 함수가  `axis` 매개 변수에 'x' | 'y' | 'z' 타입을 기대했지만 `x`변수가 getComponent 함수에 전달될 때 타입스크립트가 타입 넓히기를 해서 x의 타입이 string으로 추론되었기 때문에 오류가 발생한다.






### 왜 string으로 추론했는가?

(책의 설명)
타입스크립트는 **작성자의 의도를 추측**한다. 위의 예제에서 타입스크립트는 다음과 같은 코드를 예상했기 때문에 문자열로 추측한 것이다. 
```typescript
let x = 'x';
x = 'a';
x = 'Four score and seven years ago...';
```
타입스크립트는 타입을 추론할 때 **명확성과 유연성 사이의 균형을 유지**하려고 한다.

(추가설명) 
전제: 타입스크립트는 값을 가지고 초기화되는 변수를 발견하면 값과 호환될 수 있는 타입 중 **가능한한 가장 구체적인 타입**을 해당 변수의 타입으로 추론한다. 

해당 변수는 `x`라는 **문자열 값**(단일값)으로 초기화 되었는데 
1. 이 값과 호환될 수 있는 타입들(가능한 값들의 집합) 중에서
	-   `string`
	-   `'x'`
	-   `'x' | 'y'`
	-   `'x' | 'y' | 'z'`
	-   `string | number`
	-   `string | number | boolean`
	-   그 외 등등
2.  가장 구체적인(타입이 바뀔 일 없는) 것이 string이기 때문에

string으로 추론했다.




### 넓히기를 제어하는 법

1. const로 변수 선언하기
	- let 대신 const로 변수를 선언하면 더 좁은 타입이 된다. 왜냐하면 const로 선언한 변수는 재할당 될 수 없기 때문.

**주의사항**
그러나 const로 선언한다고 해도 객체와 배열의 경우, 여전히 문제가 있을 수 있다.

```typescript
const v = { 
	x: 1, 
};

// 이 시점에서 'v'객체는 `{x: 1}`값으로 할당되었기 때문에 가장 구체적인 경우(변수가 불변하는)는 `{ readonly x: 1}`이 된다. 이 타입이라면 `x` 속성이 읽기 전용이므로 `v.x` 값을 변경할 수 없다.

//하지만 타입스크립트는 초기화 값의 구체성에 따라 해당 변수의 타입을 추론할 때 초기화 값의 타입보다 더 추상적인 타입을 추론할 수 있다. 객체의 프로퍼티와 값에 따라서 가능한 객체 타입은 달라질 수 있고 너무 구체적인 타입을 추론하면 해당 변수에 다양한 값을 할당할 수 없기 때문에 초기화 값의 타입보다 더 추상적인 타입을 추론한다. 따라서 {x: number}로 타입을 추론한다.

v.x = 3;  // 타입이 number 이므로 오류가 나지 않음.

v.x = '3'; // 타입 오류가 발생한다. v 객체가 초기화될 때 x속성의 값이 `number`로 추론되었기 때문이다.

v.y = 4; // 타입 오류가 발생한다. 객체의 타입이 {x: number}이므로 `y`속성은 존재하지 않는 속성으로 판단되기 때문이다.

v.name = 'Pythagoras';  // 위와 같은 이유로 타입 오류가 발생한다.

```

위의 코드와 같은 경우, 타입추론의 강도를 직접 제어하려면 다음의 방법을 쓰면 된다.

1. 명시적 타입구문을 제공하기
```typescript
const v: {x: 1|3|5} = {
	x: 1;
} // 타입이 { x: 1|3|5 }
```


2. 타입 체커에 추가적인 문맥을 제공하기 (Item 26 참고)
	예) 함수의 매개변수로 값을 전달

3. const 단언문을 사용하는 것. (선언문 아니고 단언문 주의)
	const 단언문은 타입 공간에서만 사용하는 기법
```typescript
const v1 = {
	x: 1,
	y: 2,
};

const v2 = {
	x: 1 as const,
	y: 2,
}; // 타입은 {x: 1; y: number}
// 문자열 리터럴 타입으로 추론한 이유는 이게 가장 좁은 타입이기 때문이다.

const v3 = {
	x: 1,
	y: 2,
} as const; // 타입은 {readonly x: 1; readonly y: 2; }
// 위에서 설명했을 때, 객체가 할당된 변수를 const로 선언해도, 프로퍼티의 값을 수정할 수 있는 객체이기 때문에 타입 넓히기의 제어가 안되었었다. 그런데 여기서는 단언문을 사용해 객체를 상수형태로 만들었다. 다시말해 객체의 속성 값을 수정하지 못하게 했다는 것이므로 readonly 타입(읽기전용)으로 처리했다.
```

값 뒤에 as const를 작성하면 **최대한 좁은 타입**으로 추론한다.